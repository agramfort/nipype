"""The fsl module provides classes for interfacing with the `FSL
<http://www.fmrib.ox.ac.uk/fsl/index.html>`_ command line tools.  This
was written to work with FSL version 4.1.4.

Examples
--------
See the docstrings of the individual classes for examples.

"""

import os
import re
import subprocess
from glob import glob
import warnings

from nipype.interfaces.fsl.base import FSLCommand
from nipype.interfaces.base import Bunch
from nipype.utils.filemanip import fname_presuffix, filename_to_list
from nipype.utils.docparse import get_doc

warn = warnings.warn
warnings.filterwarnings('always', category=UserWarning)


class EddyCorrect(FSLCommand):
    """Use FSL eddy_correct command for correction of eddy current distortion
    """
    opt_map = {}

    @property
    def cmd(self):
        """sets base command, immutable"""
        return 'eddy_correct'

    def inputs_help(self):
        """Print command line documentation for eddy_correct."""
        print get_doc(self.cmd, self.opt_map, trap_error=False)

    def _populate_inputs(self):
        self.inputs = Bunch(infile=None, outfile=None, reference_vol=None)

    def _parse_inputs(self):
        """validate fsl eddy_correct options"""

        # Add infile and outfile to the args if they are specified
        allargs = []
        if self.inputs.infile:
            allargs.insert(0, self.inputs.infile)
            if not self.inputs.outfile:
                # If the outfile is not specified but the infile is,
                # generate an outfile
                _, fname = os.path.split(self.inputs.infile)
                newpath = os.getcwd()
                self.inputs.outfile = fname_presuffix(fname, suffix='_eddc',
                                                      newpath=newpath)
        if self.inputs.outfile:
            allargs.insert(1, self.inputs.outfile)

        if self.inputs.reference_vol:
            allargs.insert(2, repr(self.inputs.reference_vol))

        return allargs

    def run(self, infile=None, outfile=None, **inputs):
        """Execute the command.
        >>> from nipype.interfaces import fsl
        >>> edd = fsl.EddyCorrect(infile='foo.nii', outfile='bar.nii', reference_vol=10)
        >>> edd.cmdline
        'eddy_correct foo.nii bar.nii 10'

        """

        if infile:
            self.inputs.infile = infile
        if not self.inputs.infile:
            raise AttributeError('Eddy_correct requires an input file')
        if outfile:
            self.inputs.outfile = outfile
        self.inputs.update(**inputs)
        return super(EddyCorrect, self).run()

    def outputs_help(self):
        """
        Parameters
        ----------
        (all default to None and are unset)

        outfile : /path/to/outfile
            filename of resulting eddy current corrected file
        """
        print self.outputs_help.__doc__

    def outputs(self):
        """Returns a :class:`nipype.interfaces.base.Bunch` with outputs

        Parameters
        ----------
        (all default to None and are unset)

            outfile : string,file
                path/name of file of eddy-corrected image
        """
        outputs = Bunch(outfile=None)
        return outputs

    def aggregate_outputs(self):
        """Create a Bunch which contains all possible files generated
        by running the interface.  Some files are always generated, others
        depending on which ``inputs`` options are set.

        Returns
        -------
        outputs : Bunch object
            Bunch object containing all possible files generated by
            interface object.

            If None, file was not generated
            Else, contains path, filename of generated outputfile

        """
        outputs = self.outputs()
        if self.inputs.outfile:
            outfile = self.inputs.outfile
        else:
            _, fname = os.path.split(self.inputs.infile)
            outfile = os.path.join(os.getcwd(),
                                   fname_presuffix(fname, suffix='_eddc'))

        if len(glob(outfile)) == 1:
            outputs.outfile = outfile

        return outputs


class Bedpostx(FSLCommand):
    """ Use FSL  bedpostx command for local modelling of diffusion parameters
    """

    opt_map = {
        'fibres': ('-n %d', 'number of fibres per voxel (opt, )'),
        'weight': ('-w %.2f', 'ARD weight (opt,)'),
        'burn_period': ('-b %d', 'burnin period (opt,)'),
        'jumps': ('-j %d', 'number of jumps (opt,)'),
        'sampling': ('-s %d', 'sampling interval (opt,)'),
        }

    @property
    def cmd(self):
        """sets base command, immutable"""
        return 'bedpostx'

    def inputs_help(self):
        """Print command line documentation for eddy_correct."""
        print get_doc(self.cmd, self.opt_map, trap_error=False)

    def _populate_inputs(self):
        self.inputs = Bunch(directory=None,
                            fibres=None,
                            weight=None,
                            burn_period=None,
                            jumps=None,
                            sampling=None)

    def _parse_inputs(self):
        """validate fsl bedpostx options"""
        allargs = super(Bedpostx, self)._parse_inputs(skip=('directory'))

        # Add directory to the args if they are specified
        if self.inputs.directory:
            allargs.insert(0, self.inputs.directory)
        else:
            raise AttributeError('Bedpostx requires a directory \
                                    name where all input files are')

        return allargs

    def run(self, directory=None, noseTest=False, **inputs):
        """Execute the command.
        >>> from nipype.interfaces import fsl
        >>> bedp = fsl.Bedpostx(directory='subj1', fibres=1)
        >>> bedp.cmdline
        'bedpostx subj1 -n 1'

        """

        if directory:
            self.inputs.directory = directory
        if not self.inputs.directory:
            raise AttributeError('Bedpostx requires a directory with standardized files')

        # incorporate other user options
        self.inputs.update(**inputs)

        # check that input directory has all the input files required
        if not noseTest:
            if not bedpostX_datacheck_ok(self.inputs.directory):
                raise AttributeError('Not all required files found in input \
                                    directory: %s' % self.inputs.directory)

        results = self._runner()
        if results.runtime.returncode == 0:
            results.outputs = self.aggregate_outputs()

        return results

    def outputs_help(self):
        """
        Parameters
        ----------
        (all default input values set to None)

        outfile : /path/to/directory_with_input_files/files
            the files are
            1) merged_th<i-th fibre>samples - 4D volume - Samples from the distribution on theta
            2) merged_ph<i-th fibre>samples - Samples from the distribution on phi
            3) merged_f<i-th fibre>samples - 4D volume - Samples from the
                distribution on anisotropic volume fraction (see technical report).
            4) mean_th<i-th fibre>samples - 3D Volume - Mean of distribution on theta
            5) mean_ph<i-th fibre>samples - 3D Volume - Mean of distribution on phi
            6) mean_f<i-th fibre>samples - 3D Volume - Mean of distribution on f anisotropy
            7) dyads<i-th fibre> - Mean of PDD distribution in vector form.
            8) nodif_brain - brain extracted version of nodif - copied from input directory
            9) nodif_brain_mask - binary mask created from nodif_brain - copied from input directory

        """
        print self.outputs_help.__doc__

    def outputs(self):
        """Returns a :class:`nipype.interfaces.base.Bunch` with outputs

        Parameters
        ----------
        (all default to None and are unset)

            outfile : string,file
                path/name of file of bedpostx image
        """
        outputs = Bunch(bvals=None,
                        bvecs=None,
                        nodif_brain=None,
                        nodif_brain_mask=None)
        return outputs

    def aggregate_outputs(self):
        """Create a Bunch which contains all possible files generated
        by running the interface.  Some files are always generated, others
        depending on which ``inputs`` options are set.

        Returns
        -------
        outputs : Bunch object
            Bunch object containing all possible files generated by
            interface object.

            If None, file was not generated
            Else, contains path, filename of generated outputfile

        For bedpostx, the jobs get send to the sge if available and thus

        """

        outputs = self.outputs()
        #get path and names of the essential files that were generated by bedpostx
        files = glob(self.inputs.directory + '.bedpostX/*')
        for line in files:
            if re.search('bvals', line) is not None:
                outputs.bvals = line

            elif re.search('bvecs', line) is not None:
                outputs.bvecs = line

            elif re.search('nodif_brain\.', line) is not None:
                outputs.nodif_brain = line

            elif re.search('nodif_brain_mask\.', line) is not None:
                outputs.nodif_brain_mask = line

        return outputs


class Dtifit(FSLCommand):
    """Use FSL  dtifit command for fitting a diffusion tensor model at each voxel
    """

    opt_map = {
        'data':                     '-k %s',
        'basename':                 '-o %s',
        'bet_binary_mask':          '-m %s',
        'b_vector_file':            '-r %s',
        'b_value_file':             '-b %s',
        'min_z':                    '-z %d',
        'max_z':                    '-Z %d',
        'min_y':                    '-y %d',
        'max_y':                    '-Y %d',
        'min_x':                    '-x %d',
        'max_x':                    '-X %d',
        'verbose':                  '-V',
        'save_tensor':              '--save_tensor',
        'sum_squared_errors':       '--sse',
        'inp_confound_reg':         '--cni',
        'small_brain_area':         '--littlebit'}

    @property
    def cmd(self):
        """sets base command, immutable"""
        return 'dtifit'

    def inputs_help(self):
        """Print command line documentation for dtifit."""
        print get_doc(self.cmd, self.opt_map, trap_error=False)

    def _populate_inputs(self):
        self.inputs = Bunch(data=None,
                            basename=None,
                            bet_binary_mask=None,
                            b_vector_file=None,
                            b_value_file=None,
                            min_z=None,
                            max_z=None,
                            min_y=None,
                            max_y=None,
                            min_x=None,
                            max_x=None,
                            verbose=None,
                            save_tensor=None,
                            sum_squared_errors=None,
                            inp_confound_reg=None,
                            small_brain_area=None)

    def _parse_inputs(self):
        """validate fsl dtifit options"""
        allargs = super(Dtifit, self)._parse_inputs()
        return allargs

    def run(self, data=None, noseTest=False, **inputs):
        """Execute the command.
        >>> from nipype.interfaces import fsl
        >>> dti = fsl.Dtifit(data='subj1Test')
        >>> dti.cmdline
        'dtifit -k subj1Test'
        """

        if data:
            self.inputs.data = data
        if not self.inputs.data:
            raise AttributeError('Dtifit requires input data')

        # incorporate other user options
        self.inputs.update(**inputs)

        # if data is a directory check existence of standardized files
        if not noseTest:

            if os.path.isdir(self.inputs.data):
                if not bedpostX_datacheck_ok(self.inputs.data):
                    raise AttributeError('Not all standardized files found \
                                        in input directory: %s' \
                                       % self.inputs.data)

            # if data is not a directory, check existences of inputs
            elif os.path.isfile(self.inputs.data):
                if not (os.path.exists(self.inputs.b_vector_file) \
                        and os.path.exists(self.inputs.b_value_file) \
                        and os.path.exists(self.inputs.bet_binary_mask)):
                    raise AttributeError('Not all standardized files have been supplied \
                            (ie. b_values_file, b_vector_file, and bet_binary_mask')

            else:
                raise AttributeError('Wrong input for Dtifit')

        results = self._runner()
        if results.runtime.returncode == 0:
            results.outputs = self.aggregate_outputs()

        return results

    def outputs_help(self):
        """
        Parameters
        ----------
        (all default input values set to None)

        outfile : /path/to/directory_with_output_files/files
            the files are
            1) <basename>_V1 - 1st eigenvector
            2) <basename>_V2 - 2nd eigenvector
            3) <basename>_V3 - 3rd eigenvector
            4) <basename>_L1 - 1st eigenvalue
            5) <basename>_L2 - 2nd eigenvalue
            6) <basename>_L3 - 3rd eigenvalue
            7) <basename>_MD - mean diffusivity
            8) <basename>_FA - fractional anisotropy
            9) <basename>_SO - raw T2 signal with no diffusion weighting
        """
        print self.outputs_help.__doc__

    def outputs(self):
        """Returns a :class:`nipype.interfaces.base.Bunch` with outputs

        Parameters
        ----------
        (all default to None and are unset)

            outfile : string,file
                path/name of file of dtifit image
        """
        outputs = Bunch(V1=None, V2=None, V3=None,
                        L1=None, L2=None, L3=None,
                        MD=None, FA=None, SO=None)

        return outputs

    def aggregate_outputs(self):
        """Create a Bunch which contains all possible files generated
        by running the interface.  Some files are always generated, others
        depending on which ``inputs`` options are set.

        Returns
        -------
        outputs : Bunch object
            Bunch object containing all possible files generated by
            interface object.

            If None, file was not generated
            Else, contains path, filename of generated outputfile

        """
        outputs = self.outputs()
        #get path and names of the essential files that were generated by dtifit
        files = glob(os.getcwd() + '/' + self.inputs.basename + '*')
        for line in files:
            if re.search('_V1\.', line) is not None:
                outputs.V1 = line

            elif re.search('_V2\.', line) is not None:
                outputs.V2 = line

            elif re.search('_V3\.', line) is not None:
                outputs.V3 = line

            elif re.search('_L1\.', line) is not None:
                outputs.L1 = line

            elif re.search('_L2\.', line) is not None:
                outputs.L2 = line

            elif re.search('_L3\.', line) is not None:
                outputs.L3 = line

            elif re.search('_MD\.', line) is not None:
                outputs.MD = line

            elif re.search('_FA\.', line) is not None:
                outputs.FA = line

            elif re.search('_SO\.', line) is not None:
                outputs.SO = line

        return outputs


class Tbss2reg(FSLCommand):
    """
        Use FSL Tbss2reg for applying nonlinear registration of all FA images into standard space
    """
    opt_map = {'FMRIB58_FA_1mm':    '-T',
               'targetImage':       '-t %s',
               'findTarget':        '-n'}

    @property
    def cmd(self):
        """sets base command, immutable"""
        return 'tbss_2_reg'

    def inputs_help(self):
        """Print command line documentation for tbss_2_reg."""
        print get_doc(self.cmd, self.opt_map, trap_error=False)

    def _populate_inputs(self):
        self.inputs = Bunch(FMRIB58_FA_1mm=None,
                            targetImage=None,
                            findTarget=None)

    def _parse_inputs(self):
        """validate fsl tbss_2_reg options"""
        allargs = super(Tbss2reg, self)._parse_inputs()
        return allargs

    def run(self, noseTest=False, **inputs):
        """Execute the command.
        >>> from nipype.interfaces import fsl
        >>> tbss2 = fsl.Tbss2reg(FMRIB58_FA_1mm=True)
        >>> tbss2.cmdline
        'tbss_2_reg -T'

        """
        self.inputs.update(**inputs)
        if (self.inputs.FMRIB58_FA_1mm is None) and \
           (self.inputs.targetImage is None) and \
           (self.inputs.findTarget is None):
            raise AttributeError('Tbss2reg needs at least one option')
        results = self._runner()
        if not noseTest:
            results.outputs = self.aggregate_outputs()
        return results

    def outputs_help(self):
        """
        Parameters
        ----------
        (all default to None and are unset)

        outfile : /path/to/outfile
            path and filename to registered images with accompanying mask files
        """
        print self.outputs_help.__doc__

    def outputs(self):
        """Returns a :class:`nipype.interfaces.base.Bunch` with outputs

        Parameters
        ----------
        (all default to None and are unset)

            outfile : string,file
                path/name of file of tbss_2_reg image
        """
        outputs = Bunch(outfiles=None)
        return outputs

    def aggregate_outputs(self):
        """Create a Bunch which contains all possible files generated
        by running the interface.  Some files are always generated, others
        depending on which ``inputs`` options are set.

        Returns
        -------
        outputs : Bunch object
            Bunch object containing all possible files generated by
            interface object.

            If None, file was not generated
            Else, contains path, filename of generated outputfile

        """
        outputs = self.outputs()
        outputs = tbss_1_2_getOutputFiles(outputs, os.getcwd())

        if not outputs.outfiles:
            raise AttributeError('No output files created for tbss_2_reg')

        return outputs


def bedpostX_datacheck_ok(directory):
        """ checks if all the required files for bedpostx/dtifit have been supplied by the user"""

        proc = subprocess.Popen('bedpostx_datacheck  ' + directory,
                     shell=True,
                     cwd=directory,
                     stdout=subprocess.PIPE,
                     stderr=subprocess.PIPE)
        [stdout, _] = proc.communicate()

        bvalandbvec = []
        totalVols = []

        output = stdout.split('\n')
        for line in output:
            if re.search('data\s+does\s+not\s+exist\s*$', line) is not None:
                raise AttributeError('No 4D series of data volumes specified.\n')
            elif re.search('nodif_brain_mask\s+does\s+not\s+exist\s*$', line) is not None:
                raise AttributeError('No nodif_brain_mask specified.\n')
            elif re.match('^dim4\s+', line) is not None:
                totalVols.append(int(line.split(' ')[-1]))
            elif line.isdigit():
                bvalandbvec.append(int(line))

        # check that the bvals and bvecs are in the right order
        if (bvalandbvec[1] == totalVols[0]) and (bvalandbvec[1] * bvalandbvec[2] == bvalandbvec[3]):
            return True
        else:
            print 'bvals and bvecs values do not correspond with volumes in data.\n'

        return False


def tbss_1_2_getOutputFiles(outputs, cwd):
    """
        Extracts path and filename from the FA folder that ought to have been created
        if tbss_1_preproc and tbss_2_reg was executed correctly
    """

    if os.path.isdir(cwd + '/FA'):
            FA_files = glob(cwd + '/FA/*')
            origdata = glob(cwd + '/origdata/*.nii.gz')
    else:
        raise AttributeError('No FA subdirectory was found in cwd: \n' + cwd)

    outputs.outfiles = []
    for line in origdata:
        _, fname = os.path.split(line)
        brainId = fname.split('.')[0]
        subject = [brainId, line]

        for FA in FA_files:
            if re.search(brainId, FA) is not None:
                subject.append(FA)
        outputs.outfiles.append(subject)

    return outputs


class Tbss1preproc(FSLCommand):
    """
        Use FSL Tbss1preproc for preparing your FA data in your TBSS working directory in the right format
    """
    opt_map = {}

    @property
    def cmd(self):
        """sets base command, immutable"""
        return 'tbss_1_preproc'

    def inputs_help(self):
        """Print command line documentation for tbss_1_preproc."""
        print get_doc(self.cmd, self.opt_map, trap_error=False)

    def _populate_inputs(self):
        self.inputs = Bunch(infiles=None)

    def _parse_inputs(self):
        """validate fsl tbss_1_preproc options"""
        return [self.inputs.infiles]

    def run(self, noseTest=False, **inputs):
        """Execute the command.
        >>> from nipype.interfaces import fsl
        >>> tbss1 = fsl.Tbss1preproc(infiles='*.nii.gz')
        >>> tbss1.cmdline
        'tbss_1_preproc *.nii.gz'

        """
        self.inputs.update(**inputs)
        if self.inputs.infiles is None:
            raise AttributeError('tbss_1_preproc requires input files')
        results = self._runner()
        if not noseTest:
            results.outputs = self.aggregate_outputs()
        return results

    def outputs_help(self):
        """
        Parameters
        ----------
        (all default to None and are unset)

        outfile : /path/to/outfile
            path and filename to the tbss preprocessed images
        """
        print self.outputs_help.__doc__

    def outputs(self):
        """Returns a :class:`nipype.interfaces.base.Bunch` with outputs

        Parameters
        ----------
        (all default to None and are unset)

            outfile : string,file
                path/name of file of tbss_1_preproc image
        """
        outputs = Bunch(outfiles=None)
        return outputs

    def aggregate_outputs(self):
        """Create a Bunch which contains all possible files generated
        by running the interface.  Some files are always generated, others
        depending on which ``inputs`` options are set.

        Returns
        -------
        outputs : Bunch object
            Bunch object containing all possible files generated by
            interface object.

            If None, file was not generated
            Else, contains path, filename of generated outputfile

        """
        outputs = self.outputs()
        outputs = tbss_1_2_getOutputFiles(outputs, os.getcwd())
        if not outputs.outfiles:
            raise AttributeError('No output files created for tbss_1_preproc')

        return outputs


class Tbss3postreg(FSLCommand):
    """
        Use FSL Tbss3postreg for creating the mean FA image and skeletonise it
    """
    opt_map = {'subject_means':     '-S',
               'FMRIB58_FA':        '-T'}

    @property
    def cmd(self):
        """sets base command, immutable"""
        return 'tbss_3_postreg'

    def inputs_help(self):
        """Print command line documentation for tbss_3_postreg."""
        print get_doc(self.cmd, self.opt_map, trap_error=False)

    def _populate_inputs(self):
        self.inputs = Bunch(subject_means=None,
                            FMRIB58_FA=None)

    def _parse_inputs(self):
        """validate fsl tbss_3_postreg options"""
        allargs = super(Tbss3postreg, self)._parse_inputs()
        return allargs

    def run(self, noseTest=False, **inputs):
        """Execute the command.
        >>> from nipype.interfaces import fsl
        >>> tbss3 = fsl.Tbss3postreg(subject_means=True)
        >>> tbss3.cmdline
        'tbss_3_postreg -S'

        """
        self.inputs.update(**inputs)
        if (self.inputs.subject_means is None) and (self.inputs.FMRIB58_FA is None):
            raise AttributeError('tbss_1_preproc requires at least one option flag to be set')
        results = self._runner()
        if not noseTest:
            results.outputs = self.aggregate_outputs()
        return results

    def outputs_help(self):
        """
        Parameters
        ----------
        (all default to None and are unset)

        outfile : /path/to/outfile
            path and filename to tbss post-registration processed image
        """
        print self.outputs_help.__doc__

    def outputs(self):
        """Returns a :class:`nipype.interfaces.base.Bunch` with outputs

        Parameters
        ----------
        (all default to None and are unset)

            outfile : string,file
                path/name of file of tbss_3_postreg image
        """
        outputs = Bunch(all_FA=None,
                        mean_FA_skeleton=None,
                        mean_FA_skeleton_mask=None,
                        mean_FA=None,
                        mean_FA_mask=None)
        return outputs

    def aggregate_outputs(self):
        """Create a Bunch which contains all possible files generated
        by running the interface.  Some files are always generated, others
        depending on which ``inputs`` options are set.

        Returns
        -------
        outputs : Bunch object
            Bunch object containing all possible files generated by
            interface object.

            If None, file was not generated
            Else, contains path, filename of generated outputfile

        """
        cwd = os.getcwd()
        outputs = self.outputs()
        if os.path.isdir(cwd + '/stats'):
            stats_files = glob(cwd + '/stats/*')
        else:
            raise AttributeError('No stats subdirectory was found in cwd: \n' + cwd)

        for imagePath in stats_files:
            if re.search('all_FA\.', imagePath):
                outputs.all_FA = imagePath
            elif re.search('mean_FA_skeleton\.', imagePath):
                outputs.mean_FA_skeleton = imagePath
            elif re.search('mean_FA\.', imagePath):
                outputs.mean_FA = imagePath
            elif re.search('mean_FA_mask\.', imagePath):
                outputs.mean_FA_mask = imagePath

        if (not outputs.all_FA) and (not outputs.mean_FA_skeleton):
            raise AttributeError('tbss_3_postreg did not create the desired files')

        return outputs


class Tbss4prestats(FSLCommand):
    """
        Use FSL Tbss4prestats thresholds the mean FA skeleton image at the chosen threshold
    """
    opt_map = {}

    @property
    def cmd(self):
        """sets base command, immutable"""
        return 'tbss_4_prestats'

    def inputs_help(self):
        """Print command line documentation for tbss_4_prestats."""
        print get_doc(self.cmd, self.opt_map, trap_error=False)

    def _populate_inputs(self):
        self.inputs = Bunch(threshold=None)

    def _parse_inputs(self):
        """validate fsl tbss_4_prestats options"""
        allargs = []
        # Add source files to the args if they are specified
        if self.inputs.threshold:
            allargs.append(str(self.inputs.threshold))
        else:
            raise AttributeError('tbss_4_prestats requires threshold')

        return allargs

    def run(self, noseTest=False, **inputs):
        """Execute the command.
        >>> from nipype.interfaces import fsl
        >>> tbss4 = fsl.Tbss4prestats(threshold=0.3)
        >>> tbss4.cmdline
        'tbss_4_prestats 0.3'

        """
        self.inputs.update(**inputs)
        results = self._runner()
        if not noseTest:
            results.outputs = self.aggregate_outputs()
        return results

    def outputs_help(self):
        """
        Parameters
        ----------
        (all default to None and are unset)

        outfile : /path/to/outfile
            path and filename to tbss prestats thresholded mean FA image
        """
        print self.outputs_help.__doc__

    def outputs(self):
        """Returns a :class:`nipype.interfaces.base.Bunch` with outputs

        Parameters
        ----------
        (all default to None and are unset)

            outfile : string,file
                path/name of file of tbss_4_prestats image
        """
        outputs = Bunch(all_FA_skeletonised=None,
                        mean_FA_skeleton_mask=None)
        return outputs

    def aggregate_outputs(self):
        """Create a Bunch which contains all possible files generated
        by running the interface.  Some files are always generated, others
        depending on which ``inputs`` options are set.

        Returns
        -------
        outputs : Bunch object
            Bunch object containing all possible files generated by
            interface object.

            If None, file was not generated
            Else, contains path, filename of generated outputfile

        """
        outputs = self.outputs()
        cwd = os.getcwd()
        if os.path.isdir(cwd + '/stats'):
            stats_files = glob(cwd + '/stats/*')
        else:
            raise AttributeError('No stats subdirectory was found in cwd: \n' + cwd)

        for imagePath in stats_files:
            if re.search('all_FA_skeletonised\.', imagePath):
                outputs.all_FA_skeletonised = imagePath
            elif re.search('mean_FA_skeleton_mask\.', imagePath):
                outputs.mean_FA_skeleton_mask = imagePath

        if not outputs.all_FA_skeletonised:
                raise AttributeError('tbss_4_prestats did not create the desired files')

        return outputs


class Randomise(FSLCommand):
    """
        FSL Randomise: feeds the 4D projected FA data into GLM modelling and thresholding
        in order to find voxels which correlate with your model
    """
    opt_map = {'input_4D':                           '-i %s',
              'output_rootname':                    '-o %s',
              'demean_data':                        '-D',
              'one_sample_gmean':                   '-1',
              'mask_image':                         '-m %s',
              'design_matrix':                      '-d %s',
              't_contrast':                         '-t %s',
              'f_contrast':                         '-f %s',
              'xchange_block_labels':               '-e %s',
              'print_unique_perm':                  '-q',
              'print_info_parallelMode':            '-Q',
              'num_permutations':                   '-n %d',
              'vox_pvalus':                         '-x',
              'fstats_only':                        '--fonly',
              'thresh_free_cluster':                '-T',
              'thresh_free_cluster_2Dopt':          '--T2',
              'cluster_thresholding':               '-c %0.2f',
              'cluster_mass_thresholding':          '-C %0.2f',
              'fcluster_thresholding':              '-F %0.2f',
              'fcluster_mass_thresholding':         '-S %0.2f',
              'variance_smoothing':                 '-v %0.2f',
              'diagnostics_off':                    '--quiet',
              'output_raw':                         '-R',
              'output_perm_vect':                   '-P',
              'int_seed':                           '--seed %d',
              'TFCE_height_param':                  '--tfce_H %0.2f',
              'TFCE_extent_param':                  '--tfce_E %0.2f',
              'TFCE_connectivity':                  '--tfce_C %0.2f',
              'list_num_voxel_EVs_pos':             '--vxl %s',
              'list_img_voxel_EVs':                 '--vxf %s'}

    @property
    def cmd(self):
        """sets base command, immutable"""
        return 'randomise'

    def inputs_help(self):
        """Print command line documentation for randomise."""
        print get_doc(self.cmd, self.opt_map, trap_error=False)

    def _populate_inputs(self):
        self.inputs = Bunch(input_4D=None,
                            output_rootname=None,
                            demean_data=None,
                            one_sample_gmean=None,
                            mask_image=None,
                            design_matrix=None,
                            t_contrast=None,
                            f_contrast=None,
                            xchange_block_labels=None,
                            print_unique_perm=None,
                            print_info_parallelMode=None,
                            num_permutations=None,
                            vox_pvalus=None,
                            fstats_only=None,
                            thresh_free_cluster=None,
                            thresh_free_cluster_2Dopt=None,
                            cluster_thresholding=None,
                            cluster_mass_thresholding=None,
                            fcluster_thresholding=None,
                            fcluster_mass_thresholding=None,
                            variance_smoothing=None,
                            diagnostics_off=None,
                            output_raw=None,
                            output_perm_vect=None,
                            int_seed=None,
                            TFCE_height_param=None,
                            TFCE_extent_param=None,
                            TFCE_connectivity=None,
                            list_num_voxel_EVs_pos=None,
                            list_img_voxel_EVs=None)

    def _parse_inputs(self):
        """validate fsl randomise options"""
        allargs = super(Randomise, self)._parse_inputs(skip=('input_4D', 'output_rootname'))

        # Add source files to the args if they are specified
        if self.inputs.input_4D:
            allargs.insert(0, '-i ' + self.inputs.input_4D)
        else:
            raise AttributeError('randomise needs a 4D image as input')

        if self.inputs.output_rootname:
            allargs.insert(1, '-o ' + self.inputs.output_rootname)

        return allargs

    def run(self, input_4D=None, output_rootname=None, **inputs):
        """Execute the command.
        >>> from nipype.interfaces import fsl
        >>> rand = fsl.Randomise(input_4D='infile2',output_rootname='outfile2',f_contrast='infile.f',one_sample_gmean=True,int_seed=4)
        >>> rand.cmdline
        'randomise -i infile2 -o outfile2 -f infile.f --seed 4 -1'
        """
        if input_4D:
            self.inputs.input_4D = input_4D
        if not self.inputs.input_4D:
            raise AttributeError('randomise requires an input file')

        if output_rootname:
            self.inputs.output_rootname = output_rootname

        self.inputs.update(**inputs)
        results = self._runner()
        if results.runtime.returncode == 0:
            results.outputs = self.aggregate_outputs()
        return results

    def outputs_help(self):
        """
        Parameters
        ----------
        (all default to None and are unset)

        outfile : /path/to/outfile
            path and filename to randomise generated files
        """
        print self.outputs_help.__doc__

    def outputs(self):
        """Returns a :class:`nipype.interfaces.base.Bunch` with outputs

        Parameters
        ----------
        (all default to None and are unset)

            outfile : string,file
                path/name of file of randomise image
        """
        outputs = Bunch(tstat=None)
        return outputs

    def aggregate_outputs(self):
        """Create a Bunch which contains all possible files generated
        by running the interface.  Some files are always generated, others
        depending on which ``inputs`` options are set.

        Returns
        -------
        outputs : Bunch object
            Bunch object containing all possible files generated by
            interface object.

            If None, file was not generated
            Else, contains path, filename of generated outputfile

        """
        outputs = self.outputs()
        randFiles = glob(self.inputs.output_rootname + '*')
        outputs.tstat = []

        for imagePath in randFiles:
            if re.search('tstat', imagePath):
                outputs.tstat.append(imagePath)

        if not outputs.tstat:
            raise AttributeError('randomise did not create the desired files')

        return outputs


class Randomise_parallel(Randomise):
    """
        FSL Randomise_parallel: feeds the 4D projected FA data into GLM modelling and thresholding
        in order to find voxels which correlate with your model
    """
    @property
    def cmd(self):
        """sets base command, immutable"""
        return 'randomise_parallel'

    def inputs_help(self):
        """Print command line documentation for randomise."""
        print get_doc('randomise', self.opt_map, trap_error=False)


class Probtrackx(FSLCommand):

    """Use FSL  probtrackx for tractography and connectivity-based segmentation
    """

    opt_map = {'basename':                      '-s %s',
               'binaryMask':                    '-m %s',
               'seedFile':                      '-x %s',
               'verbose':                       '-V %d',
               'helpDoc':                       '-h',
               'mode':                          '--mode=%s',  # options: simple, seedmask
               'targetMasks':                   '--targetmasks=%s',
               'secondMask':                    '--mask2=%s',
               'wayPointsMask':                 '--waypoints=%s',
               'activateNetwork':               '--network',
               'surfaceDescriptor':             '--mesh=%s',
               'refVol4seedVoxels':             '--seedref=%s',
               'finalVolDir':                   '--dir=%s',
               'useActualDirName':              '--forcedir',
               'outputPathDistribution':        '--opd',
               'correctPathDistribution':       '--pd',
               'outputSeeds2targets':           '--os2t',
               'outfBasename':                   '-o %s',
               'rejectMaskPaths':               '--avoid=%s',
               'noTrackingMask':                '--stop=%s',
               'preferedOrientation':           '--prefdir=%s',
               'Tmatrix':                       '--xfm=%s',
               'numOfSamples':                  '-P %d',
               'nstepsPersample':               '-S %d',
               'curvatureThreshold':            '-c %.2f',
               'steplength':                    '--steplength=%.2f',
               'performLoopcheck':              '-l',
               'useAnisotropy':                 '-f',
               'selectRandfibres':              '--randfib',
               'forceAstartingFibre':           '--fibst=%d',
               'modifiedEulerStreamlining':     '--modeuler',
               'randSeed':                      '--rseed',
               'outS2Tcounts':                  '--seedcountastext'}

    @property
    def cmd(self):
        """sets base command, immutable"""
        return 'probtrackx'

    def inputs_help(self):
        """Print command line documentation for probtrackx."""
        print get_doc(self.cmd, self.opt_map, trap_error=False)

    def _populate_inputs(self):
        self.inputs = Bunch(basename=None,
                                binaryMask=None,
                                seedFile=None,
                                verbose=None,
                                helpDoc=None,
                                mode=None,
                                targetMasks=None,
                                secondMask=None,
                                wayPointsMask=None,
                                activateNetwork=None,
                                surfaceDescriptor=None,
                                refVol4seedVoxels=None,
                                finalVolDir=None,
                                useActualDirName=None,
                                outputPathDistribution=None,
                                correctPathDistribution=None,
                                outputSeeds2targets=None,
                                outfBasename=None,
                                rejectMaskPaths=None,
                                noTrackingMask=None,
                                preferedOrientation=None,
                                Tmatrix=None,
                                numOfSamples=None,
                                nstepsPersample=None,
                                curvatureThreshold=None,
                                steplength=None,
                                performLoopcheck=None,
                                useAnisotropy=None,
                                selectRandfibres=None,
                                forceAstartingFibre=None,
                                modifiedEulerStreamlining=None,
                                randSeed=None,
                                outS2Tcounts=None)

    def _parse_inputs(self):
        """validate fsl probtrackx options"""
        allargs = super(Probtrackx, self)._parse_inputs(skip=('basename', 'binaryMask', 'seedFile'))

        # Add source files to the args if they are specified
        if self.inputs.basename:
            allargs.insert(0, '-s ' + self.inputs.basename)
        else:
            raise AttributeError('probtrackx needs a basename as input')

        if self.inputs.binaryMask:
            allargs.insert(1, '-m ' + self.inputs.binaryMask)
        else:
            raise AttributeError('probtrackx needs a binary mask as input')

        if self.inputs.seedFile:
            allargs.insert(2, '-x ' + self.inputs.seedFile)
        else:
            raise AttributeError('probtrackx needs a seed volume, or voxel, \
                                    or ascii file with multiple volumes as input')

        return allargs

    def run(self, basename=None, binaryMask=None, seedFile=None, noseTest=False, **inputs):
        """Execute the command.
        >>> from nipype.interfaces import fsl
        >>> pbx = Probtrackx(basename='subj1',binaryMask='nodif_brain_mask',seedFile='standard')
        >>> pbx.cmdline
        'probtrackx -s subj1 -m nodif_brain_mask -x standard'
        """

        if basename:
            self.inputs.basename = basename

        if binaryMask:
            self.inputs.binaryMask = binaryMask

        if seedFile:
            self.inputs.seedFile = seedFile

        # incorporate user options
        self.inputs.update(**inputs)

        if not noseTest:
            directory = os.path.join(os.getcwd(), self.inputs.basename)
            if os.path.isdir(directory):
                if not self.__datacheck_ok(directory):
                    raise AttributeError('Not all standardized files found \
                                         in input directory: %s' % directory)

        results = self._runner()
        if not noseTest:
            results.outputs = self.aggregate_outputs()

        return results

    def outputs_help(self):
        """
        Parameters
        ----------
        (all default input values set to None)

        outfile : /path/to/directory_with_output_files/files
            the files are

        """
        print self.outputs_help.__doc__

    def outputs(self):
        """Returns a :class:`nipype.interfaces.base.Bunch` with outputs

        Parameters
        ----------
        (all default to None and are unset)

            outfile : string,file
                path/name of file of probtrackx image
        """
        outputs = Bunch(outfile=None)
        return outputs

    def aggregate_outputs(self):
        """Create a Bunch which contains all possible files generated
        by running the interface.  Some files are always generated, others
        depending on which ``inputs`` options are set.

        Returns
        -------
        outputs : Bunch object
            Bunch object containing all possible files generated by
            interface object.

            If None, file was not generated
            Else, contains path, filename of generated outputfile

        """
        outputs = self.outputs()
        outputs.outfile = self._gen_fname(self.inputs.basename,
                                             fname=self.inputs.outfile,
                                             suffix='_pbx',
                                             check=True)
        return outputs

    def _datacheck_ok(self, directory):
        """ checks whether the directory given to -s <directory> flag contains
            the three required standardized files """

        merged_ph = False
        merged_th = False
        nodif_brain_mask = False

        f1 = self._glob(os.path.join(directory, 'merged_ph*'))
        if f1 is not None:
            merged_ph = True

        f2 = self._glob(os.path.join(directory, 'merged_th*'))
        if f2 is not None:
            merged_th = True

        f3 = self._glob(os.path.join(directory, 'nodif_brain_mask*'))
        if f3 is not None:
            nodif_brain_mask = True

        return (merged_ph and merged_th and nodif_brain_mask)


class Vecreg(FSLCommand):
    """Use FSL vecreg for registering vector data

    For complete details, see the `FDT Documentation
    <http://www.fmrib.ox.ac.uk/fsl/fdt/fdt_vecreg.html>`_

    """
    opt_map = {'infile':            '-i %s',
               'outfile':           '-o %s',
               'refVolName':        '-r %s',
               'verbose':           '-v',
               'helpDoc':           '-h',
               'tensor':            '--tensor',
               'affineTmat':        '-t %s',
               'warpFile':          '-w %s',
               'interpolation':     '--interp %s',
               'brainMask':         '-m %s'}

    @property
    def cmd(self):
        """sets base command, immutable"""
        return 'vecreg'

    def inputs_help(self):
        """Print command line documentation for Vecreg."""
        print get_doc(self.cmd, self.opt_map, trap_error=False)

    def _populate_inputs(self):
        self.inputs = Bunch(infile=None,
                            outfile=None,
                            refVolName=None,
                            verbose=None,
                            helpDoc=None,
                            tensor=None,
                            affineTmat=None,
                            warpFile=None,
                            interpolation=None,
                            brainMask=None,
                            cwd=None)

    def _parse_inputs(self):
        """validate fsl vecreg options"""
        allargs = super(Vecreg, self)._parse_inputs(skip=('infile', 'outfile',
                                                         'refVolName', 'cwd'))

        # Add source files to the args if they are specified
        if self.inputs.infile:
            allargs.insert(0, '-i ' + self.inputs.infile)
        else:
            raise AttributeError('vecreg needs an input file')

        if self.inputs.outfile:
            allargs.insert(1, '-o ' + self.inputs.outfile)
        else:
            outfile = self._gen_fname(self.inputs.infile,
                                         cwd=self.inputs.cwd,
                                         suffix='_vrg')
            self.inputs.outfile = outfile
            allargs.insert(1, '-o ' + outfile)

        if self.inputs.refVolName:
            allargs.insert(2, '-r ' + self.inputs.refVolName)
        else:
            raise AttributeError('vecreg needs a reference volume')

        return allargs

    def run(self, infile=None, outfile=None, refVolName=None, **inputs):
        """Execute the command.

        Examples
        --------
        >>> from nipype.interfaces import fsl
        >>> vreg = fsl.Vecreg(infile='inf', outfile='infout', \
                              refVolName='MNI152')
        >>> vreg.cmdline
        'vecreg -i inf -o infout -r MNI152'

        """
        if infile:
            self.inputs.infile = infile

        if outfile:
            self.inputs.outfile = outfile

        if refVolName:
            self.inputs.refVolName = refVolName

        self.inputs.update(**inputs)
        return super(Vecreg, self).run()

    def outputs(self):
        """Returns a :class:`nipype.interfaces.base.Bunch` with outputs

        Parameters
        ----------
        outfile : str
            path/name of file of probtrackx image
        """
        outputs = Bunch(outfile=None)
        return outputs

    def aggregate_outputs(self):
        outputs = self.outputs()
        outputs.outfile = self._gen_fname(self.inputs.infile,
                                             fname=self.inputs.outfile,
                                             cwd=self.inputs.cwd,
                                             suffix='_vrg',
                                             check=True)
        return outputs
    aggregate_outputs.__doc__ = FSLCommand.aggregate_outputs.__doc__


class ProjThresh(FSLCommand):
    """Use FSL proj_thresh for thresholding some outputs of probtrack

        For complete details, see the `FDT Documentation
        <http://www.fmrib.ox.ac.uk/fsl/fdt/fdt_thresh.html>`_

    """

    opt_map = {}

    @property
    def cmd(self):
        """sets base command, immutable"""
        return 'proj_thresh'

    def inputs_help(self):
        """Print command line documentation for Proj_thresh."""
        print get_doc(self.cmd, self.opt_map, trap_error=False)

    def _populate_inputs(self):
        self.inputs = Bunch(volumes=None, threshold=None, cwd=None)

    def _parse_inputs(self):
        """validate fsl Proj_thresh options"""
        allargs = []

        if self.inputs.volumes:
            for vol in self.inputs.volumes:
                allargs.append(vol)
        else:
            raise AttributeError('proj_thresh needs input volumes')

        if self.inputs.threshold:
            allargs.append(repr(self.inputs.threshold))
        else:
            raise AttributeError('proj_thresh needs a threshold value')

        return allargs

    def run(self, volumes=None, threshold=None, **inputs):
        """Execute the command.

        Examples
        --------
        >>> from nipype.interfaces import fsl
        >>> pThresh = fsl.ProjThresh(volumes = ['seeds_to_M1', 'seeds_to_M2'], \
                                     threshold = 3)
        >>> pThresh.cmdline
        'proj_thresh seeds_to_M1 seeds_to_M2 3'

        """

        if volumes is not None:
            self.inputs.volumes = filename_to_list(volumes)

        if threshold is not None:
            self.inputs.threshold = threshold

        self.inputs.update(**inputs)
        return super(ProjThresh, self).run()

    def outputs(self):
        """Returns a :class:`nipype.interfaces.base.Bunch` with outputs

        Parameters
        ----------
        outfile : str
            path/name of file of probtrackx image
        """
        outputs = Bunch(outfile=None)
        return outputs

    def aggregate_outputs(self):
        outputs = self.outputs()
        outputs.outfile = []

        for files in self.inputs.volumes:
            outputs.outfile.append(self._glob(files + '_proj_seg_thr_*'))

        return outputs
    aggregate_outputs.__doc__ = FSLCommand.aggregate_outputs.__doc__


class FindTheBiggest(FSLCommand):
    """Use FSL find_the_biggest for performing hard segmentation on
       the outputs of connectivity-based thresholding in probtrack.

       For complete details, see the `FDT
       Documentation. <http://www.fmrib.ox.ac.uk/fsl/fdt/fdt_biggest.html>`_

    """

    opt_map = {}

    @property
    def cmd(self):
        """sets base command, immutable"""
        return 'find_the_biggest'

    def inputs_help(self):
        """Print command line documentation for Find_the_biggest."""
        print get_doc(self.cmd, self.opt_map, trap_error=False)

    def _populate_inputs(self):
        self.inputs = Bunch(infiles=None,
                            outfile=None)

    def _parse_inputs(self):
        """validate fsl Find_the_biggest options"""
        allargs = []
        if self.inputs.infiles:
            allargs.insert(0, self.inputs.infiles)
        if self.inputs.outfile:
            allargs.insert(1, self.inputs.outfile)
        else:
            outfile = self._gen_fname(self.inputs.infiles,
                                         fname=self.inputs.outfile,
                                         suffix='_fbg')
            allargs.insert(1, outfile)

        return allargs

    def run(self, infiles=None, outfile=None, **inputs):
        """Execute the command.

        Examples
        --------
        >>> from nipype.interfaces import fsl
        >>> fBig = fsl.FindTheBiggest(infiles='all*', outfile='biggestOut')
        >>> fBig.cmdline
        'find_the_biggest all* biggestOut'

        """
        if infiles:
            self.inputs.infiles = infiles
        if not self.inputs.infiles:
            raise AttributeError('find_the_biggest requires input file(s)')
        if outfile:
            self.inputs.outfile = outfile
        return super(FindTheBiggest, self).run()

    def outputs(self):
        """Returns a :class:`nipype.interfaces.base.Bunch` with outputs

        Parameters
        ----------
        outfile : str
            path/name of file of probtrackx image
        """
        outputs = Bunch(outfile=None)
        return outputs

    def aggregate_outputs(self):
        outputs = self.outputs()
        outputs.outfile = self._gen_fname(self.inputs.infile,
                                             fname=self.inputs.outfile,
                                             suffix='_fbg',
                                             check=True)

        return outputs
    aggregate_outputs.__doc__ = FSLCommand.aggregate_outputs.__doc__
