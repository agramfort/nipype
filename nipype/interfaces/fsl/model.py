"""The fsl module provides classes for interfacing with the `FSL
<http://www.fmrib.ox.ac.uk/fsl/index.html>`_ command line tools.  This
was written to work with FSL version 4.1.4.

Examples
--------
See the docstrings of the individual classes for examples.

"""

import os
from copy import deepcopy
from glob import glob
import warnings
from shutil import rmtree

from nipype.interfaces.fsl.base import FSLCommand, FSLInfo
from nipype.interfaces.base import (Bunch, Interface, load_template,
                                    InterfaceResult)
from nipype.utils.filemanip import (list_to_filename, filename_to_list,
                                    loadflat)
from nipype.utils.docparse import get_doc
from nipype.externals.pynifti import load

warn = warnings.warn
warnings.filterwarnings('always', category=UserWarning)


class Level1Design(Interface):
    """Generate Feat specific files

    See Level1Design().inputs_help() for more information.

    Parameters
    ----------
    inputs : mapping
    key, value pairs that will update the Level1Design.inputs attributes
    see self.inputs_help() for a list of Level1Design.inputs attributes

    Attributes
    ----------
    inputs : Bunch
    a (dictionary-like) bunch of options that can be passed to
    spm_smooth via a job structure
    cmdline : string
    string used to call matlab/spm via SpmMatlabCommandLine interface

    Other Parameters
    ----------------
    To see optional arguments
    Level1Design().inputs_help()

    Examples
    --------

    """

    def __init__(self, *args, **inputs):
        self._populate_inputs()
        self.inputs.update(**inputs)

    @property
    def cmd(self):
        return 'fsl_fmri_design'

    def get_input_info(self):
        """ Provides information about inputs as a dict
            info = [Bunch(key=string,copy=bool,ext='.nii'),...]
        """
        return []

    def inputs_help(self):
        """
        Parameters
        ----------

        interscan_interval : float (in secs)
            Interscan  interval,  TR.
        session_info : list of bunches
            Stores session specific information generated by
            ``modelgen.SpecifyModel``
        bases : dict {'name':{'basesparam1':val,...}}
            name : string
                Name of basis function (hrf - double gamma hrf)

                hrf :
                    derivs : boolean
                        Model  HRF  Derivatives.
        model_serial_correlations : string
            Option to model serial correlations using an
            autoregressive estimator. Setting this option is only
            useful in the context of the fsf file. You need to repeat
            this option for FilmGLS
        contrasts : list of dicts
            List of contrasts with each list containing: 'name', 'stat',
            [condition list], [weight list].
        register : boolean
            Run registration at the end of session specific analysis.
            default - True
        reg_image : file
            image volume to register to. default -
                    MNI152_T1_2mm_brain.nii.gz
        reg_dof : int
            registration degrees of freedom. default - 12
        """
        print self.inputs_help.__doc__

    def _populate_inputs(self):
        """ Initializes the input fields of this interface.
        """
        self.inputs = Bunch(interscan_interval=None,
                            session_info=None,
                            bases=None,
                            model_serial_correlations=None,
                            contrasts=None,
                            register=True,
                            reg_image=None,
                            reg_dof=12)

    def _create_ev_file(self, evfname, evinfo):
        f = open(evfname, 'wt')
        for i in evinfo:
            if len(i) == 3:
                f.write('%f %f %f\n' % (i[0], i[1], i[2]))
            else:
                f.write('%f\n' % i[0])
        f.close()

    def _create_ev_files(self, cwd, runinfo, runidx, usetd, contrasts):
        """Creates EV files from condition and regressor information.

           Parameters:
           -----------

           runinfo : dict
               Generated by `SpecifyModel` and contains information
               about events and other regressors.
           runidx  : int
               Index to run number
           usetd   : int
               Whether or not to use temporal derivatives for
               conditions
           contrasts : list of lists
               Information on contrasts to be evaluated
        """
        conds = {}
        evname = []
        ev_hrf = load_template('feat_ev_hrf.tcl')
        ev_none = load_template('feat_ev_none.tcl')
        ev_ortho = load_template('feat_ev_ortho.tcl')
        contrast_header = load_template('feat_contrast_header.tcl')
        contrast_prolog = load_template('feat_contrast_prolog.tcl')
        contrast_element = load_template('feat_contrast_element.tcl')
        contrastmask_header = load_template('feat_contrastmask_header.tcl')
        contrastmask_footer = load_template('feat_contrastmask_footer.tcl')
        contrastmask_element = load_template('feat_contrastmask_element.tcl')
        ev_txt = ''
        # generate sections for conditions and other nuisance
        # regressors
        num_evs = [0, 0]
        for field in ['cond', 'regress']:
            for i, cond in enumerate(runinfo[field]):
                name = cond['name']
                evname.append(name)
                evfname = os.path.join(cwd, 'ev_%s_%d_%d.txt' % (name, runidx,
                                                                 len(evname)))
                evinfo = []
                num_evs[0] += 1
                num_evs[1] += 1
                if field == 'cond':
                    for j, onset in enumerate(cond['onset']):
                        if len(cond['duration']) > 1:
                            evinfo.insert(j, [onset, cond['duration'][j], 1])
                        else:
                            evinfo.insert(j, [onset, cond['duration'][0], 1])
                    ev_txt += ev_hrf.substitute(ev_num=num_evs[0],
                                                ev_name=name,
                                                temporalderiv=usetd,
                                                cond_file=evfname)
                    if usetd:
                        evname.append(name + 'TD')
                        num_evs[1] += 1
                elif field == 'regress':
                    evinfo = [[j] for j in cond['val']]
                    ev_txt += ev_none.substitute(ev_num=num_evs[0],
                                                 ev_name=name,
                                                 cond_file=evfname)
                ev_txt += "\n"
                conds[name] = evfname
                self._create_ev_file(evfname, evinfo)
        # add orthogonalization
        for i in range(1, num_evs[0] + 1):
            for j in range(0, num_evs[0] + 1):
                ev_txt += ev_ortho.substitute(c0=i, c1=j)
                ev_txt += "\n"
        # add t contrast info
        ev_txt += contrast_header.substitute()
        for ctype in ['real', 'orig']:
            for j, con in enumerate(contrasts):
                ev_txt += contrast_prolog.substitute(cnum=j + 1,
                                                     ctype=ctype,
                                                     cname=con[0])
                count = 0
                for c in range(1, len(evname) + 1):
                    if evname[c - 1].endswith('TD') and ctype == 'orig':
                        continue
                    count = count + 1
                    if evname[c - 1] in con[2]:
                        val = con[3][con[2].index(evname[c - 1])]
                    else:
                        val = 0.0
                    ev_txt += contrast_element.substitute(cnum=j + 1,
                                                          element=count,
                                                          ctype=ctype, val=val)
                    ev_txt += "\n"
        # add contrast mask info
        ev_txt += contrastmask_header.substitute()
        for j, _ in enumerate(contrasts):
            for k, _ in enumerate(contrasts):
                if j != k:
                    ev_txt += contrastmask_element.substitute(c1=j + 1,
                                                              c2=k + 1)
        ev_txt += contrastmask_footer.substitute()
        return num_evs, ev_txt

    def run(self, **inputs):
        cwd = os.getcwd()
        self.inputs.update(inputs)
        fsf_header = load_template('feat_header_l1.tcl')
        fsf_postscript = load_template('feat_nongui.tcl')

        prewhiten = int(self.inputs.model_serial_correlations == 'AR(1)')
        if self.inputs.bases and 'hrf' in self.inputs.bases:
            usetd = int(self.inputs.bases['hrf']['derivs'])
        else:
            usetd = 0
        session_info = self._get_session_info(self.inputs.session_info)
        func_files = self._get_func_files(session_info)

        n_tcon = 0
        n_fcon = 0
        for i, c in enumerate(self.inputs.contrasts):
            if c[1] == 'T':
                n_tcon += 1
            elif c[1] == 'F':
                n_fcon += 1
            else:
                print "unknown contrast type: %s" % str(c)
        print [n_tcon, n_fcon]

        register = int(self.inputs.register)
        if register:
            reg_image = self.inputs.reg_image
            if not reg_image:
                reg_image = \
                FSLInfo.standard_image('MNI152_T1_2mm_brain.nii.gz')
        reg_dof = self.inputs.reg_dof
        for i, info in enumerate(session_info):
            num_evs, cond_txt = self._create_ev_files(cwd, info, i, usetd,
                                                      self.inputs.contrasts)
            nim = load(func_files[i])
            (_, _, _, timepoints) = nim.get_shape()
            fsf_txt = fsf_header.substitute(run_num=i,
                                            interscan_interval=self.inputs.interscan_interval,
                                            num_vols=timepoints,
                                            prewhiten=prewhiten,
                                            num_evs=num_evs[0],
                                            num_evs_real=num_evs[1],
                                            num_tcon=n_tcon,
                                            num_fcon=n_fcon,
                                            high_pass_filter_cutoff=info['hpf'],
                                            func_file=func_files[i],
                                            register=register,
                                            reg_image=reg_image,
                                            reg_dof=reg_dof)
            fsf_txt += cond_txt
            fsf_txt += fsf_postscript.substitute(overwrite=1)

            f = open(os.path.join(cwd, 'run%d.fsf' % i), 'w')
            f.write(fsf_txt)
            f.close()

        runtime = Bunch(returncode=0,
                        messages=None,
                        errmessages=None)
        outputs = self.aggregate_outputs()
        return InterfaceResult(deepcopy(self), runtime, outputs=outputs)

    def _get_session_info(self, session_info_file):
        key = 'session_info'
        data = loadflat(session_info_file)
        session_info = data[key]
        if isinstance(session_info, dict):
            session_info = [session_info]
        return session_info

    def _get_func_files(self, session_info):
        """Returns functional files in the order of runs
        """
        func_files = []
        for i, info in enumerate(session_info):
            func_files.insert(i, info['scans'][0].split(',')[0])
        return func_files

    def outputs_help(self):
        """
        """
        print self.outputs.__doc__

    def outputs(self):
        """Returns a :class:`nipype.interfaces.base.Bunch` with outputs

        Parameters
        ----------
        (all default to None and are unset)

            fsf_files:
                FSL feat specification files
            func_files:
                Functional run files
            ev_files:
                condition information files
        """
        outputs = Bunch(fsf_files=None,
                        func_files=None,
                        ev_files=None)
        return outputs

    def aggregate_outputs(self):
        outputs = self.outputs()
        session_info = self._get_session_info(self.inputs.session_info)
        func_files = self._get_func_files(session_info)
        outputs.fsf_files = glob(os.path.abspath(os.path.join(os.getcwd(), 'run*.fsf')))
        outputs.func_files = func_files
        outputs.ev_files = glob(os.path.abspath(os.path.join(os.getcwd(), 'ev_*.txt')))
        return outputs


# satra: 2010-01-03
class Feat(FSLCommand):
    """Uses FSL feat to calculate first level stats
    """
    @property
    def cmd(self):
        """sets base command, immutable"""
        return 'feat'

    opt_map = {
        'fsf_file':         None,
        }

    def inputs_help(self):
        """Print command line documentation for feat_model."""
        print get_doc(self.cmd, self.opt_map, trap_error=False)

    def _parse_inputs(self):
        """validate fsl feat_model options"""
        allargs = super(Feat, self)._parse_inputs(skip=('fsf_file'))

        if self.inputs.fsf_file:
            allargs.insert(0, self.inputs.fsf_file)
        return allargs

    def run(self, fsf_file=None, **inputs):
        """Execute the command.

        Parameters
        ----------
        fsf_file : string
            File specifying the feat design spec file

        Returns
        -------
        results : InterfaceResult
            An :class:`nipype.interfaces.base.InterfaceResult` object
            with a copy of self in `interface`

        Examples
        --------
        To pass command line arguments to ``feat_model`` that are not part of
        the ``inputs`` attribute, pass them in with the ``flags``
        input.

        >>> from nipype.interfaces import fsl
        >>> fmodel = fsl.FeatModel(fsf_file='foo.fsf')
        """
        if fsf_file:
            self.inputs.fsf_file = fsf_file
        if not self.inputs.fsf_file:
            raise ValueError('FeatModel requires an input file')
        if isinstance(self.inputs.fsf_file, list):
            raise ValueError('FeatModel does not support multiple input files')
        self.inputs.update(**inputs)
        return super(Feat, self).run()

    def outputs(self):
        """
        Parameters
        ----------
        featdir: str
            Directory containing the output of feat
        """
        outputs = Bunch(featdir=None)
        return outputs

    def aggregate_outputs(self):
        outputs = self.outputs()
        outputs.featdir = glob(os.path.join(os.getcwd(), '*feat'))[0]
        return outputs


# interface to fsl command line model generation routine
# satra: 2010-01-03
class FeatModel(FSLCommand):
    """Uses FSL feat_model to generate design.mat files
    """
    @property
    def cmd(self):
        """sets base command, immutable"""
        return 'feat_model'

    opt_map = {
        'fsf_file':         None,
        }

    def inputs_help(self):
        """Print command line documentation for feat_model."""
        print get_doc(self.cmd, self.opt_map, trap_error=False)

    def _parse_inputs(self):
        """validate fsl feat_model options"""
        allargs = super(FeatModel, self)._parse_inputs(skip=('fsf_file'))

        if self.inputs.fsf_file:
            allargs.insert(0, self._get_design_root(list_to_filename(self.inputs.fsf_file)))
        return allargs

    def _get_design_root(self, infile):
        _, fname = os.path.split(infile)
        return fname.split('.')[0]

    def run(self, fsf_file=None, **inputs):
        """Execute the command.

        Parameters
        ----------
        fsf_file : string
            File specifying the feat design spec file

        Returns
        -------
        results : InterfaceResult
            An :class:`nipype.interfaces.base.InterfaceResult` object
            with a copy of self in `interface`

        Examples
        --------
        To pass command line arguments to ``feat_model`` that are not part of
        the ``inputs`` attribute, pass them in with the ``flags``
        input.

        >>> from nipype.interfaces import fsl
        >>> fmodel = fsl.FeatModel(fsf_file='foo.fsf')
        """
        if fsf_file:
            self.inputs.fsf_file = fsf_file
        if not self.inputs.fsf_file:
            raise ValueError('FeatModel requires an input file')
        if isinstance(self.inputs.fsf_file, list):
            raise ValueError('FeatModel does not support multiple input files')
        self.inputs.update(**inputs)
        return super(FeatModel, self).run()

    def outputs(self):
        """
            Parameters
            ----------
            (all default to None)

            designfile:
                Mat file containing ascii matrix for design
            confile:
                Contrast file containing contrast vectors
        """
        outputs = Bunch(designfile=None,
                        confile=None)
        return outputs

    def aggregate_outputs(self):
        outputs = self.outputs()
        root = self._get_design_root(list_to_filename(self.inputs.fsf_file))
        designfile = glob(os.path.join(os.getcwd(), '%s*.mat' % root))
        assert len(designfile) == 1, 'No mat file generated by Feat Model'
        outputs.designfile = designfile[0]
        confile = glob(os.path.join(os.getcwd(), '%s*.con' % root))
        assert len(confile) == 1, 'No con file generated by Feat Model'
        outputs.confile = confile[0]
        return outputs


# interface to fsl command line model fit routines
# ohinds: 2009-12-28
class FilmGLS(FSLCommand):
    """Use FSL film_gls command to fit a design matrix to voxel timeseries

    To print out the command line help, use:
        fsl.FilmGLS().inputs_help()

    Examples
    --------
    Initialize Bet with no options, assigning them when calling run:

    >>> from nipype.interfaces import fsl
    >>> fgls = fsl.FilmGLS()
    >>> res = fgls.run('infile', 'designfile', 'thresh', rn='stats')

    Assign options through the ``inputs`` attribute:

    >>> fgls = fsl.FilmGLS()
    >>> fgls.inputs.infile = 'filtered_func_data'
    >>> fgls.inputs.designfile = 'design.mat'
    >>> fgls.inputs.thresh = 10
    >>> fgls.inputs.rn = 'stats'
    >>> res = fgls.run()

    Specify options when creating an instance:

    >>> fgls = fsl.FilmGLS(infile='filtered_func_data', \
                           designfile='design.mat', \
                           thresh=10, rn='stats')
    >>> res = fgls.run()

    """

    @property
    def cmd(self):
        """sets base command, immutable"""
        return 'film_gls'

    opt_map = {
        'sa':             '-sa',
        'ms':             '-ms %d',
        'epith':          '-epith %d',
        'v':              '-v',
        'ac':             '-ac',
        'ar':             '-ar',
        'tukey':          '-tukey %d',
        'mt':             '-mt %d',
        'pava':           '-pava',
        'noest':          '-noest',
        'output_pwdata':  '-output_pwdata',
        'rn':             '-rn %s',
        'infile':         None,
        'designfile':     None,
        'thresh':         None,
        }
    # Currently we don't support -ven, -vef

    def inputs_help(self):
        """Print command line documentation for film_gls."""
        print get_doc(self.cmd, self.opt_map, trap_error=False)

    def _parse_inputs(self):
        """validate fsl film_gls options"""
        allargs = super(FilmGLS, self)._parse_inputs(skip=('infile',
                                                           'designfile',
                                                           'thresh'))

        # special defaults
        if not self.inputs.rn:
            allargs.append("-rn %s" % self._get_statsdir())

        if self.inputs.infile:
            allargs.append(list_to_filename(self.inputs.infile))

        if self.inputs.designfile:
            allargs.append(list_to_filename(self.inputs.designfile))

        if self.inputs.thresh:
            allargs.append(str(self.inputs.thresh))
        else:
            allargs.append('1000')

        return allargs

    def _get_statsdir(self):
        statsdir = self.inputs.rn
        if not statsdir:
            _, name = os.path.split(list_to_filename(self.inputs.designfile))
            statsdir = '.'.join((os.path.splitext(name)[0], 'stats'))
        return statsdir

    def run(self, infile=None, designfile=None, thresh=None, **inputs):
        """Execute the command.

        Parameters
        ----------
        infile : string
            File specifying the functional data to be fit
        designfile : string
            File specifying design matrix
        thresh : float
            Some sort of threshold, not even sure this is used?

        inputs : dict
            Additional ``inputs`` assignments can be passed in.  See
            Examples section.

        Returns
        -------
        results : InterfaceResult
            An :class:`nipype.interfaces.base.InterfaceResult` object
            with a copy of self in `interface`

        Examples
        --------
        To pass command line arguments to ``film_gls`` that are not part of
        the ``inputs`` attribute, pass them in with the ``flags``
        input.

        >>> from nipype.interfaces import fsl
        >>> import os
        >>> fgls = fsl.FilmGLS(infile='foo.nii', \
                               designfile='design.mat', \
                               thresh=10, \
                               flags='-ven')
        """
        if infile:
            self.inputs.infile = infile
        if self.inputs.infile is None:
            raise ValueError('FilmGLS requires an input file')
        if isinstance(self.inputs.infile, list):
            raise ValueError('FilmGLS does not support multiple input files')
        if designfile:
            self.inputs.designfile = designfile
        if self.inputs.designfile is None:
            raise ValueError('FilmGLS requires a design file')
        if isinstance(self.inputs.designfile, list):
            raise ValueError('FilmGLS does not support multiple design files')
        if thresh:
            self.inputs.thresh = thresh
        self.inputs.update(**inputs)
        cwd = os.getcwd()
        statsdir = self._get_statsdir()
        if os.access(os.path.join(cwd, statsdir), os.F_OK):
            rmtree(os.path.join(cwd, statsdir))
        return super(FilmGLS, self).run()

    def outputs(self):
        """
            Parameters
            ----------
            (all default to None)

            pes:
                Parameter estimates for each column of the design matrix
                for each voxel
            res4d:
                Model fit residual mean-squared error for each time point
            dof:
                degrees of freedom
            sigmasquareds:
                See Woolrich, et. al., 2001
            statsdir :
                directory storing model estimation output
        """
        outputs = Bunch(pes=None,
                        res4d=None,
                        dof=None,
                        sigmasquareds=None,
                        statsdir=None)
        return outputs

    def aggregate_outputs(self):
        outputs = self.outputs()
        pth = os.path.join(os.getcwd(), self._get_statsdir())

        pes = glob(os.path.join(pth, 'pe[0-9]*.*'))
        assert len(pes) >= 1, 'No pe volumes generated by FSL Estimate'
        outputs.pes = pes

        res4d = glob(os.path.join(pth, 'res4d.*'))
        assert len(res4d) == 1, 'No residual volume generated by FSL Estimate'
        outputs.res4d = res4d[0]

        dof = glob(os.path.join(pth, 'dof'))
        assert len(dof) == 1, 'No degrees of freedom files generated by FSL Estimate'
        outputs.dof = dof

        sigmasquareds = glob(os.path.join(pth, 'sigmasquareds.*'))
        assert len(sigmasquareds) == 1, 'No sigmasquareds volume generated by FSL Estimate'
        outputs.sigmasquareds = sigmasquareds[0]

        outputs.statsdir = os.path.join(os.getcwd(), self._get_statsdir())

        return outputs


# satra: 2010-01-23
class FixedEffectsModel(Interface):
    """Generate Feat specific files

    See FixedEffectsModel().inputs_help() for more information.

    Examples
    --------

    """

    def __init__(self, *args, **inputs):
        self._populate_inputs()
        self.inputs.update(**inputs)

    @property
    def cmd(self):
        return 'feat_fe_design'

    def get_input_info(self):
        """ Provides information about inputs as a dict
            info = [Bunch(key=string,copy=bool,ext='.nii'),...]
        """
        return []

    def inputs_help(self):
        """
        Parameters
        ----------

        feat_dirs : list of directory names
            Lower level feat dirs
        num_copes : int
            number of copes evaluated in each session
        """
        print self.inputs_help.__doc__

    def _populate_inputs(self):
        """ Initializes the input fields of this interface.
        """
        self.inputs = Bunch(feat_dirs=None,
                            num_copes=None)

    def run(self, **inputs):
        self.inputs.update(inputs)
        fsf_header = load_template('feat_fe_header.tcl')
        fsf_footer = load_template('feat_fe_footer.tcl')
        fsf_copes = load_template('feat_fe_copes.tcl')
        fsf_dirs = load_template('feat_fe_featdirs.tcl')
        fsf_ev_header = load_template('feat_fe_ev_header.tcl')
        fsf_ev_element = load_template('feat_fe_ev_element.tcl')

        num_runs = len(filename_to_list(self.inputs.feat_dirs))
        fsf_txt = fsf_header.substitute(num_runs=num_runs,
                                        num_copes=self.inputs.num_copes)
        for i in range(self.inputs.num_copes):
            fsf_txt += fsf_copes.substitute(copeno=i + 1)
        for i, rundir in enumerate(filename_to_list(self.inputs.feat_dirs)):
            fsf_txt += fsf_dirs.substitute(runno=i + 1,
                                           rundir=os.path.abspath(rundir))
        fsf_txt += fsf_ev_header.substitute()
        for i in range(1, num_runs + 1):
            fsf_txt += fsf_ev_element.substitute(input=i)
        fsf_txt += fsf_footer.substitute(overwrite=1)

        f = open(os.path.join(os.getcwd(), 'fixedeffects.fsf'), 'wt')
        f.write(fsf_txt)
        f.close()

        runtime = Bunch(returncode=0,
                        messages=None,
                        errmessages=None)
        outputs = self.aggregate_outputs()
        return InterfaceResult(deepcopy(self), runtime, outputs=outputs)

    def outputs_help(self):
        """
        """
        print self.outputs.__doc__

    def outputs(self):
        """Returns a :class:`nipype.interfaces.base.Bunch` with outputs

        Parameters
        ----------
        (all default to None and are unset)

            fsf_file:
                FSL feat specification file
        """
        outputs = Bunch(fsf_file=None)
        return outputs

    def aggregate_outputs(self):
        outputs = self.outputs()
        outputs.fsf_file = glob(os.path.abspath(os.path.join(os.getcwd(), 'fixed*.fsf')))[0]
        return outputs


# satra: 2010-01-23
class FeatRegister(Interface):
    """Register feat directories to a specific standard

    See FixedEffectsModel().inputs_help() for more information.

    Examples
    --------

    """

    def __init__(self, *args, **inputs):
        self._populate_inputs()
        self.inputs.update(**inputs)

    @property
    def cmd(self):
        return 'feat_register'

    def get_input_info(self):
        """ Provides information about inputs as a dict
            info = [Bunch(key=string,copy=bool,ext='.nii'),...]
        """
        return []

    def inputs_help(self):
        """
        Parameters
        ----------

        feat_dirs : list of directory names
            Lower level feat dirs
        reg_image : file
            image to register to (will be treated as standard)
        reg_dof : int
            registration degrees of freedom [ default : 12 ]
        """
        print self.inputs_help.__doc__

    def _populate_inputs(self):
        """ Initializes the input fields of this interface.
        """
        self.inputs = Bunch(feat_dirs=None,
                            reg_image=None,
                            reg_dof=12)

    def run(self, **inputs):
        self.inputs.update(inputs)
        fsf_header = load_template('featreg_header.tcl')
        fsf_footer = load_template('feat_nongui.tcl')
        fsf_dirs = load_template('feat_fe_featdirs.tcl')

        num_runs = len(filename_to_list(self.inputs.feat_dirs))
        fsf_txt = fsf_header.substitute(num_runs=num_runs,
                                        regimage=self.inputs.reg_image,
                                        regdof=self.inputs.reg_dof)
        for i, rundir in enumerate(filename_to_list(self.inputs.feat_dirs)):
            fsf_txt += fsf_dirs.substitute(runno=i + 1,
                                           rundir=os.path.abspath(rundir))
        fsf_txt += fsf_footer.substitute()
        f = open(os.path.join(os.getcwd(), 'register.fsf'), 'wt')
        f.write(fsf_txt)
        f.close()

        runtime = Bunch(returncode=0,
                        messages=None,
                        errmessages=None)
        outputs = self.aggregate_outputs()
        return InterfaceResult(deepcopy(self), runtime, outputs=outputs)

    def outputs_help(self):
        """
        """
        print self.outputs.__doc__

    def outputs(self):
        """Returns a :class:`nipype.interfaces.base.Bunch` with outputs

        Parameters
        ----------
        (all default to None and are unset)

            fsf_file:
                FSL feat specification file
        """
        outputs = Bunch(fsf_file=None)
        return outputs

    def aggregate_outputs(self):
        outputs = self.outputs()
        outputs.fsf_files = glob(os.path.abspath(os.path.join(os.getcwd(), 'reg*.fsf')))
        return outputs


# interface to fsl command line higher level model fit
# satra: 2010-01-09
class Flameo(FSLCommand):
    """Use FSL flameo command to perform higher level model fits

    To print out the command line help, use:
        fsl.Flameo().inputs_help()

    Examples
    --------
    Initialize Flameo with no options, assigning them when calling run:

    >>> from nipype.interfaces import fsl
    >>> flame = fsl.Flameo()
    >>> res = flame.run()

    >>> from nipype.interfaces import fsl
    >>> import os
    >>> flameo = fsl.Flameo(copefile='cope.nii.gz', \
                            varcopefile='varcope.nii.gz', \
                            designfile='design.mat', \
                            tconfile='design.con', \
                            runmode='fe')
    >>> flameo.cmdline
    'flameo --copefile=cope.nii.gz --designfile=design.mat --runmode=fe --tcontrastsfile=design.con --varcopefile=varcope.nii.gz'
    """

    @property
    def cmd(self):
        """sets base command, immutable"""
        return 'flameo'

    opt_map = {
        'copefile':       '--copefile=%s',
        'varcopefile':    '--varcopefile=%s',
        'dofvarcopefile': '--dofvarcopefile=%s',
        'maskfile':       '--maskfile=%s',
        'designfile':     '--designfile=%s',
        'tconfile':       '--tcontrastsfile=%s',
        'fconfile':       '--fcontrastsfile=%s',
        'covsplitfile':   '--covsplitfile=%s',
        'runmode':        '--runmode=%s',
        'njumps':         '--njumps=%d',
        'burnin':         '--burnin=%d',
        'sampleevery':    '--sampleevery=%d',
        'fixmean':        '--fixmean',
        'inferoutliers':  '--inferoutliers',
        'nopeoutput':     '--nopeoutput',
        'modelselect':    '--msm=%s',
        'sigma_dofs':     '--sigma_dofs=%s',
        'outlier_iter':   '--ioni=%d',
        'flags':          '%s'}
        # no support for ven, vef

    def inputs_help(self):
        """Print command line documentation for flameo."""
        print get_doc(self.cmd, self.opt_map, trap_error=False)

    def outputs(self):
        """
            Parameters
            ----------
            (all default to None)
            pes:
                Parameter estimates for each column of the design matrix
                for each voxel
            varcopes:
                Variance estimates
            res4d:
                Model fit residual mean-squared error for each time point
            dof:
                degrees of freedom
            copes:
                Contrast estimates for each contrast
            varcopes:
                Variance estimates for each contrast
            zstats:
                z-stat file for each contrast
            tstats:
                t-stat file for each contrast
            neff:
                neff file??
            statsdir :
                directory storing model estimation output
        """
        outputs = Bunch(pes=None,
                        res4d=None,
                        dof=None,
                        copes=None,
                        varcopes=None,
                        zstats=None,
                        tstats=None,
                        neffs=None,
                        statsdir=None)
        return outputs

    def aggregate_outputs(self):
        outputs = self.outputs()
        pth = os.getcwd()

        pes = glob(os.path.join(pth, 'pe[0-9]*.*'))
        assert len(pes) >= 1, 'No pe volumes generated by FSL Estimate'
        outputs.pes = pes

        res4d = glob(os.path.join(pth, 'res4d.*'))
        assert len(res4d) == 1, 'No residual volume generated by FSL Estimate'
        outputs.res4d = res4d[0]

        dof = glob(os.path.join(pth, 'dof'))
        assert len(dof) == 1, 'No degrees of freedom files generated by FSL Estimate'
        outputs.dof = dof

        copes = glob(os.path.join(pth, 'cope[0-9]*.*'))
        assert len(copes) >= 1, 'No cope volumes generated by FSL CEstimate'
        outputs.copes = copes

        varcopes = glob(os.path.join(pth, 'varcope[0-9]*.*'))
        assert len(varcopes) >= 1, 'No varcope volumes generated by FSL CEstimate'
        outputs.varcopes = varcopes

        zstats = glob(os.path.join(pth, 'zstat[0-9]*.*'))
        assert len(zstats) >= 1, 'No zstat volumes generated by FSL CEstimate'
        outputs.zstats = zstats

        tstats = glob(os.path.join(pth, 'tstat[0-9]*.*'))
        assert len(tstats) >= 1, 'No tstat volumes generated by FSL CEstimate'
        outputs.tstats = tstats

        neffs = glob(os.path.join(pth, 'neff[0-9]*.*'))
        assert len(neffs) >= 1, 'No neff volumes generated by FSL CEstimate'
        outputs.neffs = neffs

        outputs.statsdir = pth

        return outputs


class ContrastMgr(FSLCommand):
    """Use FSL contrast_mgr command to evaluate contrasts

    To print out the command line help, use:
        fsl.ContrastMgr().inputs_help()

    Examples
    --------
    """

    @property
    def cmd(self):
        """sets base command, immutable"""
        return 'contrast_mgr'

    opt_map = {
        'tconfile':      None,
        'fconfile':      '-f %a',
        'statsdir':       None,
        'cope':          '-cope %d',
        'suffix':        '-suffix %s',
        }

    def inputs_help(self):
        """Print command line documentation for film_gls."""
        print get_doc(self.cmd, self.opt_map, trap_error=False)

    def _parse_inputs(self):
        """validate fsl contrast_mgr options"""
        allargs = super(ContrastMgr, self)._parse_inputs(skip=('tconfile',
                                                               'statsdir',))
        if self.inputs.statsdir:
            allargs.append(list_to_filename(self.inputs.statsdir))
        else:
            raise Exception('statsdir is mandatory')
        if self.inputs.tconfile:
            allargs.append(list_to_filename(self.inputs.tconfile))
        else:
            raise Exception('tconfile is mandatory')
        return allargs

    def run(self, tconfile=None, statsdir=None, **inputs):
        """Execute the command.

        Parameters
        ----------
        tconfile : file
            contrast specification file generated by FeatModel
        statsdir : directory
            directory containing model fit data
        inputs : dict
            Additional ``inputs`` assignments can be passed in.  See
            Examples section.

        Returns
        -------
        results : InterfaceResult
            An :class:`nipype.interfaces.base.InterfaceResult` object
            with a copy of self in `interface`

        Examples
        --------

        >>> from nipype.interfaces import fsl
        >>> import os
        >>> fgls = fsl.ContrastMgr(statsdir='stats',tconfile='run0.con')
        >>> fgls.cmdline
        'contrast_mgr stats run0.con'
        """
        if tconfile:
            self.inputs.tconfile = tconfile
        if not self.inputs.tconfile:
            raise ValueError('ContrastMgr requires an tconfile')
        if isinstance(self.inputs.tconfile, list):
            raise ValueError('ContrastMgr does not support multiple tcon files')
        if statsdir:
            self.inputs.statsdir = statsdir
        if not self.inputs.statsdir:
            raise ValueError('ContrastMgr requires a statsdir')
        if isinstance(self.inputs.statsdir, list):
            raise ValueError('ContrastMgr does not support multiple statsdirs')
        self.inputs.update(**inputs)
        return super(ContrastMgr, self).run()

    def outputs(self):
        """
            Parameters
            ----------
            (all default to None)

            copes:
                Contrast estimates for each contrast
            varcopes:
                Variance estimates for each contrast
            zstats:
                z-stat file for each contrast
            tstats:
                t-stat file for each contrast
            neff:
                neff file??
            statsdir :
                directory storing model estimation output
        """
        outputs = Bunch(copes=None,
                        varcopes=None,
                        zstats=None,
                        tstats=None,
                        neffs=None,
                        statsdir=None)
        return outputs

    def aggregate_outputs(self):
        outputs = self.outputs()
        pth = self.inputs.statsdir

        copes = glob(os.path.join(pth, 'cope[0-9]*.*'))
        assert len(copes) >= 1, 'No cope volumes generated by FSL CEstimate'
        outputs.copes = copes

        varcopes = glob(os.path.join(pth, 'varcope[0-9]*.*'))
        assert len(varcopes) >= 1, 'No varcope volumes generated by FSL CEstimate'
        outputs.varcopes = varcopes

        zstats = glob(os.path.join(pth, 'zstat[0-9]*.*'))
        assert len(zstats) >= 1, 'No zstat volumes generated by FSL CEstimate'
        outputs.zstats = zstats

        tstats = glob(os.path.join(pth, 'tstat[0-9]*.*'))
        assert len(tstats) >= 1, 'No tstat volumes generated by FSL CEstimate'
        outputs.tstats = tstats

        neffs = glob(os.path.join(pth, 'neff[0-9]*.*'))
        assert len(neffs) >= 1, 'No neff volumes generated by FSL CEstimate'
        outputs.neffs = neffs

        outputs.statsdir = self.inputs.statsdir

        return outputs

# satra: 2010-01-23
class L2Model(Interface):
    """Generate design files for level 2 models

    Examples
    --------

    """

    def __init__(self, *args, **inputs):
        self._populate_inputs()
        self.inputs.update(**inputs)

    @property
    def cmd(self):
        return 'level2_design'

    def get_input_info(self):
        """ Provides information about inputs as a dict
            info = [Bunch(key=string,copy=bool,ext='.nii'),...]
        """
        return []

    def inputs_help(self):
        """
        Parameters
        ----------

        num_copes : int
            number of copes evaluated in each session
        """
        print self.inputs_help.__doc__

    def _populate_inputs(self):
        """ Initializes the input fields of this interface.
        """
        self.inputs = Bunch(num_copes=None)

    def run(self, **inputs):
        cwd = os.getcwd()

        mat_txt = ['/NumWaves       1',
                   '/NumPoints      %d' % self.inputs.num_copes,
                   '/PPheights      %e' % 1,
                   '',
                   '/Matrix']
        for i in range(self.inputs.num_copes):
            mat_txt += ['%e' % 1]
        mat_txt = '\n'.join(mat_txt)
        
        con_txt = ['/ContrastName1   group mean',
                   '/NumWaves       1',
                   '/NumContrasts   1',
                   '/PPheights          %e' % 1,
                   '/RequiredEffect     100.0', #XX where does this
                   #number come from
                   '',
                   '/Matrix',
                   '%e' % 1]
        con_txt = '\n'.join(con_txt)

        grp_txt = ['/NumWaves       1',
                   '/NumPoints      %d' % self.inputs.num_copes,
                   '',
                   '/Matrix']
        for i in range(self.inputs.num_copes):
            grp_txt += ['1']
        grp_txt = '\n'.join(grp_txt)
        
        txt = {'design.mat' : mat_txt,
               'design.con' : con_txt,
               'design.grp' : grp_txt}

        # write design files
        for i, name in enumerate(['design.mat','design.con','design.grp']):
            f = open(os.path.join(cwd, name), 'wt')
            f.write(txt[name])
            f.close()

        runtime = Bunch(returncode=0,
                        messages=None,
                        errmessages=None)
        outputs = self.aggregate_outputs()
        return InterfaceResult(deepcopy(self), runtime, outputs=outputs)

    def outputs_help(self):
        """
        """
        print self.outputs.__doc__

    def outputs(self):
        """Returns a :class:`nipype.interfaces.base.Bunch` with outputs

        Parameters
        ----------
        (all default to None and are unset)

            design_mat:
                flameo design.mat file
            design_con:
                flameo design.con file
            design_grp:
                flameo design.grp file
        """
        outputs = Bunch(design_mat=None,
                        design_con=None,
                        design_grp=None)
        return outputs

    def aggregate_outputs(self):
        outputs = self.outputs()
        for field, value in outputs.items():
            setattr(outputs, field,
                    list_to_filename(glob(os.path.join(os.getcwd(),
                                                       field.replace('_','.')))))
        return outputs
